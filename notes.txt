Questions and Notes

! Questions

! can't figure out how to compile the module in a different file 
! and still have the program that uses it find it

! are you not allowed to add allocate an array in a module?


!End Questions

!Notes

!to compile a program, use gfortran [program name]
!to run a program type ./[filename]
! use lapack for any actually linear algebra
! 1.d0 is a intrinsic fortran double
! 1.e0 is an intrinsic fortran single
! parameter tag makes it a final, it doesn't change throughout
! four parts of fortran code: function, program, subroutine, and module
!End Notes

To get lots of warnings, use gfortran -Wall tridiag.f90 tridiag_driver.f90 
You compile the module and the driver in the same line



Notes 2/28
Allocate one new comp tridiagonal inside of horner's method, and use that, and then throw it away. Make sure that the degree is correct. 

Make the size and degree instance values of the tridiagonal matrix polynomial. 

Test on a matrix polynomial with known eigenvalues, and see how it works. For a 10x10 quadratic, there are 20 eigenvalues. Test on all twenty of these and see how close I am to zero. 

For an algorithm to work, it should have good stopping criteria and good initial estimates.

Big update: We are going to put the add and multiply methods inside a subroutine that updates the current value of Horner's method. So we lose modularity, but we never have to allocate anything. We just pass the coefficient, the current value, and the scalar, and do all the addition and multiplication inside there, and never allocate anything.




Notes 3/21

In the future I shouldn't name variables "size" and "degree," I should name them "m" and "n"

Test on a matrix polynomial with known eigenvalues, and see how it works. For a 10x10 quadratic, there are 20 eigenvalues. Test on all twenty of these and see how close I am to zero. 

Because we can already do scalar times array, we don't need a subroutine to do the horner's step, just multiply the entire array in a for loop 

Hyman's method for Tridiagonal Problems

Part 1 for next week
Look at subroutine check_lag 224-233, and use that to implement horner's method to get the derivate and the second derivative because we need this for hyman's. 

Part 2 for next week
Horner's method is prone to overflow, esp if the number and coefficients are greater than one

Reversal polynomial 
p_r(z) = z^mp(1/z)
= a_m + a_m-1z + .... + a_0z^m

So just start with a_0 in Horner's method, not a big deal to switch.

Can also see on the FPML, r_check_lag does this line 174-185. 

Doing it this way avoids overflow if z> 1

So just make another horner's method to evaluate the reversal, both should be subroutines, both should have h, h', and h''. They have always been called a, b, and c. They should be passed a, b, and c, and then change them, since it's a subroutine. 


3/28

Allocate memory for the compD1, compd2 with their own statements, don't just point them to existing arrays. In the end, this won't matter, because everything is going to become a subroutine in the long run.  So for now we'll allocate and deallocate them at the beginning and the end. Also make memory for b and c in the driver line 23 in tridiag_driver.

Always use make uninstall before pushing so you don't push up the mod and object files.

Next steps: Make a horners and a horners reversal, so that you don't have a branch deep in the code. 

Look into how to load in problems from a csv file. Look in FPML line 30. tridiag driver [filename]. Look at lines 30-39. Star means read in the entire thing. Start with reading in real. Expect numbers in the form (real, imaginary). First column is always lower, second column is middle, third column is all the upper. Because it knows the size, it will know how far to read down each column before moving to the next coefficient. 

Nick314159/LMPEP shows how to format matrices, in accuracy_test driver it shows how to read them in. In line 76. Set lower main upper as the rows, then have 3*(degree + 1) rows. 


Questions and Notes

! Questions

! can't figure out how to compile the module in a different file 
! and still have the program that uses it find it

! are you not allowed to add allocate an array in a module?


!End Questions

!Notes

!to compile a program, use gfortran [program name]
!to run a program type ./[filename]
! use lapack for any actually linear algebra
! 1.d0 is a intrinsic fortran double
! 1.e0 is an intrinsic fortran single
! parameter tag makes it a final, it doesn't change throughout
! four parts of fortran code: function, program, subroutine, and module
!End Notes

To get lots of warnings, use gfortran -Wall tridiag.f90 tridiag_driver.f90 
You compile the module and the driver in the same line


!Questions

Should scalar multiplication change the matrix or just return the new value
Throwing/handling errors?

Not sure why size was an argument of print method, could easily do it without.

Should we assume that there's decreasing degree matrix polynomials, or should entry in the MP array include the degree of the coefficient

Should I do Horner's recursively?


Notes 2/28
Allocate one new comp tridiagonal inside of horner's method, and use that, and then throw it away. Make sure that the degree is correct. 

Make the size and degree instance values of the tridiagonal matrix polynomial. 

Test on a matrix polynomial with known eigenvalues, and see how it works. For a 10x10 quadratic, there are 20 eigenvalues. Test on all twenty of these and see how close I am to zero. 

For an algorithm to work, it should have good stopping criteria and good initial estimates.

Big update: We are going to put the add and multiply methods inside a subroutine that updates the current value of Horner's method. So we lose modularity, but we never have to allocate anything. We just pass the coefficient, the current value, and the scalar, and do all the addition and multiplication inside there, and never allocate anything.

3/21 Meeting

In the future I shouldn't name variables "size" and "degree," I should name them "m" and "n"

Test on a matrix polynomial with known eigenvalues, and see how it works. For a 10x10 quadratic, there are 20 eigenvalues. Test on all twenty of these and see how close I am to zero. 

Because we can already do scalar times array, we don't need a subroutine to do the horner's step, just multiply the entire array in a for loop 

Hyman's method for Tridiagonal Problems

Part 1 for next week
Look at subroutine check_lag 224-233, and use that to implement horner's method to get the derivate and the second derivative because we need this for hyman's. 

Part 2 for next week
Horner's method is prone to overflow, esp if the number and coefficients are greater than one

Reversal polynomial 
p_r(z) = z^mp(1/z)
= a_m + a_m-1z + .... + a_0z^m

So just start with a_0 in Horner's method, not a big deal to switch.

Can also see on the FPML, r_check_lag does this line 174-185. 

Doing it this way avoids overflow if z> 1

So just make another horner's method to evaluate the reversal, both should be subroutines, both should have h, h', and h''. They have always been called a, b, and c. They should be passed a, b, and c, and then change them, since it's a subroutine. 